
####1、sync.Mutex

    多个协程（goroutine）同时写同一个变量，在高并发下会发生冲突。确保一次只有一个协程可以访问变量以避免冲突，
    互斥锁可以解决这个问题。
    
    sync.Mutex 是golang中的互斥锁，实现了多个协程加锁和解锁。
    
    
####2、支持并发读写

    上一章节实现了LRU淘汰算法，接下来使用 sync.Mutex 封装 LRU 的几个方法，支持并发读写数据
    
####3、主体结构 Group
    
    group是 最核心的数据结构，负责与用户交互，并且控制缓存值存储和获取流程。
                                是
    接收 key --> 检查是否被缓存 -----> 返回缓存值 ⑴
                    |  否                         是
                    |-----> 是否应当从远程节点获取 -----> 与远程节点交互 --> 返回缓存值 ⑵
                                |  否
                                |-----> 调用`回调函数`，获取值并添加到缓存 --> 返回缓存值 ⑶
  

#####3、1 回调 Getter

    如果缓存不存在，应该从数据源（文件、数据库等）获取数据并添加到缓存中。那么是否应该支持多数据源配置呢，不应该，1、数据源种类太多，没法
    一一实现；2、拓展性不好。如何从源头获取数据，是用户决定的问题，把它交给用户，设计一个回调函数，当缓存不存在时，调用回调函数，得到源数据
    
    定义一个函数类型 F，并且实现接口 A 的方法，然后在这个方法里面调用自己。这就是 Go 语言中将其他函数（参数返回值与 F 一致）转换为接口 A
    的常用技巧。
    